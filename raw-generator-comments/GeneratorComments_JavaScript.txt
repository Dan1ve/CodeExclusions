!!!!!!!!!!!!!!!!! edit below this line at your own risk !!!!!!!!!!!!!!!!!!!!!!!
@author Ed Spencer @class Ext.data.association.BelongsTo Represents a many to one association with another model. The owner model is expected to have a foreign key which references the primary key of the associated model: Ext.define('Category', { extend: 'Ext.data.Model', fields: [ { name: 'id', type: 'int' }, { name: 'name', type: 'string' } ] }); Ext.define('Product', { extend: 'Ext.data.Model', fields: [ { name: 'id', type: 'int' }, { name: 'category_id', type: 'int' }, { name: 'name', type: 'string' } ], // we can use the belongsTo shortcut on the model to create a belongsTo association associations: [ { type: 'belongsTo', model: 'Category' } ] }); In the example above we have created models for Products and Categories, and linked them together by saying that each Product belongs to a Category. This automatically links each Product to a Category based on the Product's category_id, and provides new functions on the Product model: ## Generated getter function The first function that is added to the owner model is a getter function: var product = new Product({ id: 100, category_id: 20, name: 'Sneakers' }); product.getCategory(function(category, operation) { // do something with the category object alert(category.get('id')); // alerts 20 }, this); The getCategory function was created on the Product model when we defined the association. This uses the Category's configured {@link Ext.data.proxy.Proxy proxy} to load the Category asynchronously, calling the provided callback when it has loaded. The new getCategory function will also accept an object containing success, failure and callback properties - callback will always be called, success will only be called if the associated model was loaded successfully and failure will only be called if the associatied model could not be loaded: product.getCategory({ reload: true, // force a reload if the owner model is already cached callback: function(category, operation) {}, // a function that will always be called success : function(category, operation) {}, // a function that will only be called if the load succeeded failure : function(category, operation) {}, // a function that will only be called if the load did not succeed scope : this // optionally pass in a scope object to execute the callbacks in }); In each case above the callbacks are called with two arguments - the associated model instance and the {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is useful when the instance could not be loaded. Once the getter has been called on the model, it will be cached if the getter is called a second time. To force the model to reload, specify reload: true in the options object. ## Generated setter function The second generated function sets the associated model instance - if only a single argument is passed to the setter then the following two calls are identical: // this call... product.setCategory(10); // is equivalent to this call: product.set('category_id', 10); An instance of the owner model can also be passed as a parameter. If we pass in a second argument, the model will be automatically saved and the second argument passed to the owner model's {@link Ext.data.Model#save save} method: product.setCategory(10, function(product, operation) { // the product has been saved alert(product.get('category_id')); //now alerts 10 }); //alternative syntax: product.setCategory(10, { callback: function(product, operation), // a function that will always be called success : function(product, operation), // a function that will only be called if the load succeeded failure : function(product, operation), // a function that will only be called if the load did not succeed scope : this //optionally pass in a scope object to execute the callbacks in }) ## Customisation Associations reflect on the models they are linking to automatically set up properties such as the {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified: Ext.define('Product', { fields: [...], associations: [ { type: 'belongsTo', model: 'Category', primaryKey: 'unique_id', foreignKey: 'cat_id' } ] }); Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'category_id') with our own settings. Usually this will not be needed.
@cfg {Object} config List of configuration options with their default values, for which automatically accessor methods are generated. For example: Ext.define('SmartPhone', { config: { hasTouchScreen: false, operatingSystem: 'Other', price: 500 }, constructor: function(cfg) { this.initConfig(cfg); } }); var iPhone = new SmartPhone({ hasTouchScreen: true, operatingSystem: 'iOS' }); iPhone.getPrice(); // 500; iPhone.getOperatingSystem(); // 'iOS' iPhone.getHasTouchScreen(); // true;
@class Ext.Container @extends Ext.BoxComponent <p>Base class for any {@link Ext.BoxComponent} that may contain other Components. Containers handle the basic behavior of containing items, namely adding, inserting and removing items.</p> <p>The most commonly used Container classes are {@link Ext.Panel}, {@link Ext.Window} and {@link Ext.TabPanel}. If you do not need the capabilities offered by the aforementioned classes you can create a lightweight Container to be encapsulated by an HTML element to your specifications by using the <code><b>{@link Ext.Component#autoEl autoEl}</b></code> config option. This is a useful technique when creating embedded {@link Ext.layout.ColumnLayout column} layouts inside {@link Ext.form.FormPanel FormPanels} for example.</p> <p>The code below illustrates both how to explicitly create a Container, and how to implicitly create one using the <b><code>'container'</code></b> xtype:<pre><code> explicitly create a Container var embeddedColumns = new Ext.Container({ autoEl: 'div', // This is the default layout: 'column', defaults: { implicitly create Container by specifying xtype xtype: 'container', autoEl: 'div', // This is the default. layout: 'form', columnWidth: 0.5, style: { padding: '10px' } }, The two items below will be Ext.Containers, each encapsulated by a &lt;DIV> element. items: [{ items: { xtype: 'datefield', name: 'startDate', fieldLabel: 'Start date' } }, { items: { xtype: 'datefield', name: 'endDate', fieldLabel: 'End date' } }] });</code></pre></p> <p><u><b>Layout</b></u></p> <p>Container classes delegate the rendering of child Components to a layout manager class which must be configured into the Container using the <code><b>{@link #layout}</b></code> configuration property.</p> <p>When either specifying child <code>{@link #items}</code> of a Container, or dynamically {@link #add adding} Components to a Container, remember to consider how you wish the Container to arrange those child elements, and whether those child elements need to be sized using one of Ext's built-in <b><code>{@link #layout}</code></b> schemes. By default, Containers use the {@link Ext.layout.ContainerLayout ContainerLayout} scheme which only renders child components, appending them one after the other inside the Container, and <b>does not apply any sizing</b> at all.</p> <p>A common mistake is when a developer neglects to specify a <b><code>{@link #layout}</code></b> (e.g. widgets like GridPanels or TreePanels are added to Containers for which no <code><b>{@link #layout}</b></code> has been specified). If a Container is left to use the default {@link Ext.layout.ContainerLayout ContainerLayout} scheme, none of its child components will be resized, or changed in any way when the Container is resized.</p> <p>Certain layout managers allow dynamic addition of child components. Those that do include {@link Ext.layout.CardLayout}, {@link Ext.layout.AnchorLayout}, {@link Ext.layout.FormLayout}, and {@link Ext.layout.TableLayout}. For example:<pre><code> Create the GridPanel. var myNewGrid = new Ext.grid.GridPanel({ store: myStore, columns: myColumnModel, title: 'Results', // the title becomes the title of the tab }); myTabPanel.add(myNewGrid); // {@link Ext.TabPanel} implicitly uses {@link Ext.layout.CardLayout CardLayout} myTabPanel.{@link Ext.TabPanel#setActiveTab setActiveTab}(myNewGrid); </code></pre></p> <p>The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses {@link Ext.layout.CardLayout} as its layout manager which means all its child items are sized to {@link Ext.layout.FitLayout fit} exactly into its client area. <p><b><u>Overnesting is a common problem</u></b>. An example of overnesting occurs when a GridPanel is added to a TabPanel by wrapping the GridPanel <i>inside</i> a wrapping Panel (that has no <code><b>{@link #layout}</b></code> specified) and then add that wrapping Panel to the TabPanel. The point to realize is that a GridPanel <b>is</b> a Component which can be added directly to a Container. If the wrapping Panel has no <code><b>{@link #layout}</b></code> configuration, then the overnested GridPanel will not be sized as expected.<p> <p><u><b>Adding via remote configuration</b></u></p> <p>A server side script can be used to add Components which are generated dynamically on the server. An example of adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain parameters: </p><pre><code> execute an Ajax request to invoke server side script: Ext.Ajax.request({ url: 'gen-invoice-grid.php', send additional parameters to instruct server script params: { startDate: Ext.getCmp('start-date').getValue(), endDate: Ext.getCmp('end-date').getValue() }, process the response object to add it to the TabPanel: success: function(xhr) { var newComponent = eval(xhr.responseText); // see discussion below myTabPanel.add(newComponent); // add the component to the TabPanel myTabPanel.setActiveTab(newComponent); }, failure: function() { Ext.Msg.alert("Grid create failed", "Server communication failure"); } }); </code></pre> <p>The server script needs to return an executable Javascript statement which, when processed using <code>eval()</code>, will return either a config object with an {@link Ext.Component#xtype xtype}, or an instantiated Component. The server might return this for example:</p><pre><code> (function() { function formatDate(value){ return value ? value.dateFormat('M d, Y') : ''; }; var store = new Ext.data.Store({ url: 'get-invoice-data.php', baseParams: { startDate: '01/01/2008', endDate: '01/31/2008' }, reader: new Ext.data.JsonReader({ record: 'transaction', idProperty: 'id', totalRecords: 'total' }, [ 'customer', 'invNo', {name: 'date', type: 'date', dateFormat: 'm/d/Y'}, {name: 'value', type: 'float'} ]) }); var grid = new Ext.grid.GridPanel({ title: 'Invoice Report', bbar: new Ext.PagingToolbar(store), store: store, columns: [ {header: "Customer", width: 250, dataIndex: 'customer', sortable: true}, {header: "Invoice Number", width: 120, dataIndex: 'invNo', sortable: true}, {header: "Invoice Date", width: 100, dataIndex: 'date', renderer: formatDate, sortable: true}, {header: "Value", width: 120, dataIndex: 'value', renderer: 'usMoney', sortable: true} ], }); store.load(); return grid; // return instantiated component })(); </code></pre> <p>When the above code fragment is passed through the <code>eval</code> function in the success handler of the Ajax request, the code is executed by the Javascript processor, and the anonymous function runs, and returns the instantiated grid component.</p> <p>Note: since the code above is <i>generated</i> by a server script, the <code>baseParams</code> for the Store, the metadata to allow generation of the Record layout, and the ColumnModel can all be generated into the code since these are all known on the server.</p> @xtype container
@class Ext.data.association.HasOne Represents a one to one association with another model. The owner model is expected to have a foreign key which references the primary key of the associated model: Ext.define('Address', { extend: 'Ext.data.Model', fields: [ { name: 'id', type: 'int' }, { name: 'number', type: 'string' }, { name: 'street', type: 'string' }, { name: 'city', type: 'string' }, { name: 'zip', type: 'string' }, ] }); Ext.define('Person', { extend: 'Ext.data.Model', fields: [ { name: 'id', type: 'int' }, { name: 'name', type: 'string' }, { name: 'address_id', type: 'int'} ], // we can use the hasOne shortcut on the model to create a hasOne association associations: [{ type: 'hasOne', model: 'Address' }] }); In the example above we have created models for People and Addresses, and linked them together by saying that each Person has a single Address. This automatically links each Person to an Address based on the Persons address_id, and provides new functions on the Person model: ## Generated getter function The first function that is added to the owner model is a getter function: var person = new Person({ id: 100, address_id: 20, name: 'John Smith' }); person.getAddress(function(address, operation) { // do something with the address object alert(address.get('id')); // alerts 20 }, this); The getAddress function was created on the Person model when we defined the association. This uses the Persons configured {@link Ext.data.proxy.Proxy proxy} to load the Address asynchronously, calling the provided callback when it has loaded. The new getAddress function will also accept an object containing success, failure and callback properties - callback will always be called, success will only be called if the associated model was loaded successfully and failure will only be called if the associatied model could not be loaded: person.getAddress({ reload: true, // force a reload if the owner model is already cached callback: function(address, operation) {}, // a function that will always be called success : function(address, operation) {}, // a function that will only be called if the load succeeded failure : function(address, operation) {}, // a function that will only be called if the load did not succeed scope : this // optionally pass in a scope object to execute the callbacks in }); In each case above the callbacks are called with two arguments - the associated model instance and the {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is useful when the instance could not be loaded. Once the getter has been called on the model, it will be cached if the getter is called a second time. To force the model to reload, specify reload: true in the options object. ## Generated setter function The second generated function sets the associated model instance - if only a single argument is passed to the setter then the following two calls are identical: // this call... person.setAddress(10); // is equivalent to this call: person.set('address_id', 10); An instance of the owner model can also be passed as a parameter. If we pass in a second argument, the model will be automatically saved and the second argument passed to the owner model's {@link Ext.data.Model#save save} method: person.setAddress(10, function(address, operation) { // the address has been saved alert(address.get('address_id')); //now alerts 10 }); //alternative syntax: person.setAddress(10, { callback: function(address, operation), // a function that will always be called success : function(address, operation), // a function that will only be called if the load succeeded failure : function(address, operation), // a function that will only be called if the load did not succeed scope : this //optionally pass in a scope object to execute the callbacks in }) ## Customisation Associations reflect on the models they are linking to automatically set up properties such as the {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified: Ext.define('Person', { fields: [...], associations: [ { type: 'hasOne', model: 'Address', primaryKey: 'unique_id', foreignKey: 'addr_id' } ] }); Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'address_id') with our own settings. Usually this will not be needed.
@class Ext.data.Record <p>Instances of this class encapsulate both Record <em>definition</em> information, and Record <em>value</em> information for use in {@link Ext.data.Store} objects, or any code which needs to access Records cached in an {@link Ext.data.Store} object.</p> <p>Constructors for this class are generated by passing an Array of field definition objects to {@link #create}. Instances are usually only created by {@link Ext.data.Reader} implementations when processing unformatted data objects.</p> <p>Note that an instance of a Record class may only belong to one {@link Ext.data.Store Store} at a time. In order to copy data from one Store to another, use the {@link #copy} method to create an exact copy of the Record, and insert the new instance into the other Store.</p> <p>When serializing a Record for submission to the server, be aware that it contains many private properties, and also a reference to its owning Store which in turn holds references to its Records. This means that a whole Record may not be encoded using {@link Ext.util.JSON.encode}. Instead, use the <code>{@link #data}</code> and <code>{@link #id}</code> properties.</p> <p>Record objects generated by this constructor inherit all the methods of Ext.data.Record listed below.</p> @constructor <p>This constructor should not be used to create Record objects. Instead, use {@link #create} to generate a subclass of Ext.data.Record configured with information about its constituent fields.<p> <p><b>The generated constructor has the same signature as this constructor.</b></p> @param {Object} data (Optional) An object, the properties of which provide values for the new Record's fields. If not specified the <code>{@link Ext.data.Field#defaultValue defaultValue}</code> for each field will be assigned. @param {Object} id (Optional) The id of the Record. The id is used by the {@link Ext.data.Store} object which owns the Record to index its collection of Records (therefore this id should be unique within each store). If an <code>id</code> is not specified a <b><code>{@link #phantom}</code></b> Record will be created with an {@link #Record.id automatically generated id}.
@property {Number[]} xTicks Array of pixel locations the element will snap to if we specified a horizontal graduation/interval. This array is generated automatically when you define a tick interval.
@property {Number[]} yTicks Array of pixel locations the element will snap to if we specified a vertical graduation/interval. This array is generated automatically when you define a tick interval.
Array of pixel locations the element will snap to if we specified a horizontal graduation/interval. This array is generated automatically when you define a tick interval. @property xTicks @type int[]
Array of pixel locations the element will snap to if we specified a vertical graduation/interval. This array is generated automatically when you define a tick interval. @property yTicks @type int[]
Base class for any Ext.Component that may contain other Components. Containers handle the basic behavior of containing items, namely adding, inserting and removing items. The most commonly used Container classes are Ext.panel.Panel, Ext.window.Window and Ext.tab.Panel. If you do not need the capabilities offered by the aforementioned classes you can create a lightweight Container to be encapsulated by an HTML element to your specifications by using the {@link Ext.Component#autoEl autoEl} config option. The code below illustrates how to explicitly create a Container: @example // Explicitly create a Container Ext.create('Ext.container.Container', { layout: { type: 'hbox' }, width: 400, renderTo: Ext.getBody(), border: 1, style: {borderColor:'#000000', borderStyle:'solid', borderWidth:'1px'}, defaults: { labelWidth: 80, // implicitly create Container by specifying xtype xtype: 'datefield', flex: 1, style: { padding: '10px' } }, items: [{ xtype: 'datefield', name: 'startDate', fieldLabel: 'Start date' },{ xtype: 'datefield', name: 'endDate', fieldLabel: 'End date' }] }); ## Layout Container classes delegate the rendering of child Components to a layout manager class which must be configured into the Container using the `{@link #layout}` configuration property. When either specifying child `{@link #cfg-items}` of a Container, or dynamically {@link #method-add adding} Components to a Container, remember to consider how you wish the Container to arrange those child elements, and whether those child elements need to be sized using one of Ext's built-in `{@link #layout}` schemes. By default, Containers use the {@link Ext.layout.container.Auto Auto} scheme which only renders child components, appending them one after the other inside the Container, and **does not apply any sizing** at all. A common mistake is when a developer neglects to specify a `{@link #layout}` (e.g. widgets like GridPanels or TreePanels are added to Containers for which no `{@link #layout}` has been specified). If a Container is left to use the default {@link Ext.layout.container.Auto Auto} scheme, none of its child components will be resized, or changed in any way when the Container is resized. Certain layout managers allow dynamic addition of child components. Those that do include Ext.layout.container.Card, Ext.layout.container.Anchor, Ext.layout.container.VBox, Ext.layout.container.HBox, and Ext.layout.container.Table. For example: // Create the GridPanel. var myNewGrid = Ext.create('Ext.grid.Panel', { store: myStore, headers: myHeaders, title: 'Results', // the title becomes the title of the tab }); myTabPanel.add(myNewGrid); // {@link Ext.tab.Panel} implicitly uses {@link Ext.layout.container.Card Card} myTabPanel.{@link Ext.tab.Panel#setActiveTab setActiveTab}(myNewGrid); The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses {@link Ext.layout.container.Card} as its layout manager which means all its child items are sized to {@link Ext.layout.container.Fit fit} exactly into its client area. **_Overnesting is a common problem_**. An example of overnesting occurs when a GridPanel is added to a TabPanel by wrapping the GridPanel _inside_ a wrapping Panel (that has no `{@link #layout}` specified) and then add that wrapping Panel to the TabPanel. The point to realize is that a GridPanel **is** a Component which can be added directly to a Container. If the wrapping Panel has no `{@link #layout}` configuration, then the overnested GridPanel will not be sized as expected. ## Adding via remote configuration A server side script can be used to add Components which are generated dynamically on the server. An example of adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain parameters: // execute an Ajax request to invoke server side script: Ext.Ajax.request({ url: 'gen-invoice-grid.php', // send additional parameters to instruct server script params: { startDate: Ext.getCmp('start-date').getValue(), endDate: Ext.getCmp('end-date').getValue() }, // process the response object to add it to the TabPanel: success: function(xhr) { var newComponent = eval(xhr.responseText); // see discussion below myTabPanel.add(newComponent); // add the component to the TabPanel myTabPanel.setActiveTab(newComponent); }, failure: function() { Ext.Msg.alert("Grid create failed", "Server communication failure"); } }); The server script needs to return a JSON representation of a configuration object, which, when decoded will return a config object with an {@link Ext.Component#xtype xtype}. The server might return the following JSON: { "xtype": 'grid', "title": 'Invoice Report', "store": { "model": 'Invoice', "proxy": { "type": 'ajax', "url": 'get-invoice-data.php', "reader": { "type": 'json' "record": 'transaction', "idProperty": 'id', "totalRecords": 'total' }) }, "autoLoad": { "params": { "startDate": '01/01/2008', "endDate": '01/31/2008' } } }, "headers": [ {"header": "Customer", "width": 250, "dataIndex": 'customer', "sortable": true}, {"header": "Invoice Number", "width": 120, "dataIndex": 'invNo', "sortable": true}, {"header": "Invoice Date", "width": 100, "dataIndex": 'date', "renderer": Ext.util.Format.dateRenderer('M d, y'), "sortable": true}, {"header": "Value", "width": 120, "dataIndex": 'value', "renderer": 'usMoney', "sortable": true} ] } When the above code fragment is passed through the `eval` function in the success handler of the Ajax request, the result will be a config object which, when added to a Container, will cause instantiation of a GridPanel. **Be sure that the Container is configured with a layout which sizes and positions the child items to your requirements.** **Note:** since the code above is _generated_ by a server script, the `autoLoad` params for the Store, the user's preferred date format, the metadata to allow generation of the Model layout, and the ColumnModel can all be generated into the code since these are all known on the server.
Generated by CoffeeScript 1.3.3
generated by npm, please don't touch!
generated from ldml/main/*.xml, xpath: ldml/calendars/calendar-gregorian
generated from ldml/main/*.xml, xpath: ldml/calendars/calendar-islamic-civil
generated from ldml/main/*.xml, xpath: ldml/numbers
generated from ldml/main/*.xml, xpath: ldml/numbers/currencies
Generated from lib/kss.coffee
Jison generated lexer
Jison generated parser
MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md This file is generated by `cake build`, do not edit it by hand.